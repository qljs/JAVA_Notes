

## 一 MySQL中锁

锁根据不同的维度，可以分为不同的锁：

- 根据性能来区分：**乐观锁**和**悲观锁**；
- 根据对数据库操作类型来分：**读锁（共享锁）**和**写锁（排他锁）**，这两种锁都是悲观锁，读锁会阻塞写操作，不会阻塞读操作，但是写锁会阻塞读和写；
- 根据粒度来分：**表锁**和**行锁**。



### 1. 表锁

顾名思义，表锁每次操作会锁住整张表。加锁快，开销小，不会出现死锁；但是锁的粒度加大，容易发生锁冲突，并发度低。

MyISAM引擎支持的就是表锁，在每次查询时会自动给涉及的表加上读锁，在进行写操作时，会自动给表加上写锁。



### 2. 行锁

每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁 冲突的概率最低，并发度最高。

MyISAM与InnoDB最大的不同是，InnoDB支持**行锁**和**事务**。



## 二 事务

MySQL中事务指一组SQL组成的逻辑处理单元，事务具有以下四个性质，简称为ACID：

- **原子性（Atomicity）**：事务是一个原子操作，其对数据的修改，要么全都执行，要么全不执行；
- **一致性（Consistent）**：事务开始和结束时，数据必须保持一直状态；
- **隔离性（Isolation）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
- **持久性（Durability）**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。



## 1. 并发事务带来的问题

- **丢失更新**：多个事务更新同一行数据，基于自己最初获取的值进行更新，由于感知不到其他事务的存在，就会导致覆盖了其他事务的更新结果，造成丢失更新；

- **脏读**：一个事务读取到了另一个事务已修改但是未提交的数据。当事务A读取到事务B未提交的数据后，并基于整个数据进行业务处理，而事务B之后回滚了，那么事务A之前读到就是无效数据，即脏读，不符合一致性。
- **不可重复读**：一个事务多次读取的数据不一致。例如事务A先读取了一条数据，此时事务B也对这条数据进行修改并提交事务后，当事务A再次读取该数据时，发现前后两次读取的不一致，即不可重复读，不符合隔离性。
- **幻读**：一个事务读取到另一个事务新增的数据。幻读与脏读有点相似，但是脏读是针对修改，而幻读则是针对增删的，同样，幻读也不符合隔离性。



### 2. 事务隔离级别

为了解决并发事务代理的问题，数据库提供了事务隔离机制来解决这些问题，在MySQL中，默认的隔离级别是**可重复读**，查看数据库事务隔离级别`show variables like 'tx_isolation`，设置数据库隔离级别`set tx_isolation='REPEATABLE-READ'`。

|         事务隔离级别         |  脏读  | 不可重复读 |  幻读  |
| :--------------------------: | :----: | :--------: | :----: |
| 读未提交（READ-UNCOMMITTED） |  可能  |    可能    |  可能  |
|  读已提交（READ-COMMITTED）  | 不可能 |    可能    |  可能  |
| 可重复读（REPEATABLE-READ）  | 不可能 |   不可能   |  可能  |
|   可串行化（SERIALIZABLE）   | 不可能 |   不可能   | 不可能 |



## 三 MVCC机制

MVCC 全称是 multiversion concurrency control，即多版本并发控制，是InnoDB支持并发和回滚等事务功能的重要机制，它只适用于读已提交和可重复读两种隔离级别。

通过将已修改的旧版本信息存储在名为`rollback segment`的数据结构存中，并依据`rollback segment`中的信息来执行事务回滚所需的撤消操作，构建早期版本（就是常说的快照），实现一致性读。

在InnoDB内部，为每一行添加了三个隐藏字段：

- **DB_TRX_ID**：该字段用于表示最后插入或更新改行的操作，在InnoDB中，删除被视为更新操作，行中的特殊位置会被标记为已删除。
- **DB_ROLL_PTR**：回滚指针，该字段指向undo log中记录。
- **DB_ROW_ID**：该字段包含一个行ID，随着插入新行而递增，可以理解为在我们自己没设置主键时候，MySQL自己维护的一个自增主键。



> #### Redo log、 bin log、 Undo log

- **bin log**：是mysql服务层产生的日志，记录引起数据库改变的操作，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的。对于事务，每次提交写入日志，非事务，每次执行成功写入。
- **redo log**： 记录了数据操作在物理层面的修改，mysql中使用了大量缓存，修改数据时不会直接修改磁盘中的数据，而是先修改缓存，当内存和磁盘数据不一致时，就会出现脏数据页，InnoDB会定期执行flush操作，同步数据。
- **undo log**：该日志保留了已更改行的旧版本信息，存在`rollback segment`，MVCC便是基于该日志来实现的，它分为 insert和 update，对于 insert undo log在事务提交后就可以删除。



> ### 一致性视图（快照）：ReadView

InnoDB 拥有一个自增的全局事务 ID，每当一个事务开启，在事务中都会记录当前事务的唯一 id，同时会将当前未提交的所有事务 ID 组成的数组传递给这个新事务。

对于查询操作不同的隔离级别，生成的ReadView也不一样，对于读已提交，每次执行查询都会创建新的ReadView，对于可重复读，每次执行查询，都会沿用第一次执行的快照。

在ReadView有几个重要的属性，分别是：

- **low_limit_id**：高水位线，当前最大事务序号+1，大于等于low_limit_id且当前事务ID不等于low_limit_id，对当前事务都不可见；
- **up_limit_id**：低水位线，当前已开启未提交事务的最小值，小于up_limit_id的，对于当前事务都是可见的；
- **trx_ids**：记录ReadView生成时，所有已开启未提交事务的id集合；

![](..\images\mysql\read_view.png)







> #### 举个栗子

当前有一张表`account`，假设其中id为1的记录trx_id为50：

![](..\images\mysql\mvcc1.png) 

此时，开启一个事务（trx_id=60），执行update操作并提交：

```sql
update account set balance = balance - 10 where id = 1;
```

在开启一个事务（trx_id = 70），执行update操作但是不提交：

```sql
update account set balance = balance - 20 where id = 1;
```

![](..\images\mysql\mvcc2.png)  

此时，有一个select操作，它此刻拥有的txd_ids为[70]，这个txd_id落在未提交事务部分，因此会根据版本链往下找，找到第trx_id为60的那条记录，然后返回。





## 参考

https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html

https://techlog.cn/article/list/10183404