



## 一. Redis实现分布式锁

在服务采用集群方式部署时，例如`synchronized`、`ReetrantLock`这种本地锁，无法在多个服务之间生效，此时就需要分布式锁。

Redis 锁主要利用 Redis 的`setnx`原子命令，伪代码如下。

```java
try{
    // 利用原子操作setnx加锁 
    boolean lock = redisUtil.setnx(key, value);   
    // 
    if(!lock){
        return "get lock fail";
    }
    // TODO 业务逻辑

}finally {
    redisUtil.del(key);
}
```

为了防止执行业务逻辑时出现问题，无法释放锁，需要给key设置过期时间，可以采用`set key value ex|px nx`或者使用LUA脚本。

以上加锁方式可能出现的问题：



### 1. 锁误解除与锁并发

假如线程 A 获取到锁，设置过期时间，开始执行业务逻辑，但是当线程A执行业务逻辑的时间超过了设置锁超时的时间，锁会被自动释放，此时线程 B 就可以获取到锁，此时就出现了锁并发的情况；随后线程 A 执行完业务逻辑，释放锁，但是线程 B 还未执行完，那么就相当于线程A释放了线程B的锁。

**对于锁误解除，可以通过设置唯一标识的 value，在释放时通过判断 value 是否相同，防止释放其他线程的锁。**

```java
String val = UUID.randomUUID().toString();
try{
    boolean lock = redisUtil.setnx(key, val);
    if(!lock){
        System.out.println("set fail");
        return "get lock fail";
    }
    Integer product = Integer.valueOf(redisUtil.get("product"));
    if(product > 0){
        redisUtil.decrement("product");
    }
} finally {
    if(val.equals(redisUtil.get(key))){
        redisUtil.del(key);
    }
}
```

**对于锁并发，可以通过守护线程来延长锁的存活时间。例如 Redisson等第三方框架。**

```java
@Bean
public Redisson redisson(){
    Config config = new Config();
    config.useSingleServer().setAddress("redis://172.16.33.52:6379");
    return (Redisson)Redisson.create(config);
}

RLock lock = redisson.getLock(key);
try {
    lock.lock();
    Integer product = Integer.valueOf(redisUtil.get("product"));
    if(product > 0){
        redisUtil.decrement("product");
    }

} finally {
    lock.unlock();
}
```



### 2.  Redis集群产生的问题

为了保证集群的可用性，通常会采用集群或者主从模式来部署，那么下同样会产生锁并发的问题。

- **master 宕机后，加锁的数据未同步到 slave，然后重新选举，此时另外另外一个线程在新的 master 上加锁成功，就会造成锁并发。**
- **当出现集群脑裂时，同样可能会出现锁并发的问题。**

集群脑裂指因为网络问题，导致节点处于不同的网络分区，无法感知到 master 的存在，此时会重新选举 master，造成集群中出现两个 master，此时不同线程就可以获取到同一把锁。



## 三 RedLock

为了解决 master 重新选举时，数据未及时同步问题，Redis 的作者提出了 RedLock(红锁)的算法，RedLock需要多个 Redis master 节点。其加锁步骤如下：

1. **使用相同的 key 和 value 依次尝试从不同的节点获取锁，在尝试获取锁时，需要设置一个网络连接和响应的超时时间，防止客户端一直等待；**
2. **当从超过半数的节点获取到锁时，且获取锁的时间小于锁失效的时间，那么就成功获取到锁；**
3. **如果获取锁失败，那么需要将所有节点上的锁释放。**



##  四 分布式锁存在的一些问题

对于 RedLock，Martin Kleppmann 认为其依然不安全。

### 1. 长时间GC

因为在 GC 时，会出现 STW，所以有可能会出现下面的情况：

![](..\images\redis\redlock-gc.jpg)



client1 获取到锁并设置了锁超时时间，但是此时出现了 STW，而这个 STW 时间较长，导致释放了锁，而client2 此时就可以获取到锁，当client1 的 GC 结束后，会继续执行业务代码。

对于这个问题，Martin Kleppmann 也提出了解决办法，即为每个写操作加上隔离标志。

客户端1获得锁并且获得**序号为33的令牌**，但随后它进入长时间暂停，直至锁超时过期，客户端2获取锁并且获得**序号为34的令牌**，然后将其写入发送到存储服务。随后，客户端1复活并将其写入发送到存储服务，然而存储服务器记得它**已经处理了具有较高令牌号的写入34**，因此它**拒绝令牌33的请求**。
Redlock算法并没有这种**唯一且递增的fencing token生成机制**，这也意味着Redlock算法不能避免由于客户端阻塞带来的锁过期后的操作问题，因此是不安全的。



### 2. 时钟跳跃

若 Redis 发生时钟跳跃，那么会对锁过期时间造成影响，造成获取到同一把锁。



## 五 Redisson加锁源码



### 1. LUA 脚本

```sh
EVAL script numkeys key [key ...] arg [arg ...]　
# 例子
eval "return {KEYS[1], KEYS[2], ARGV[1], ARGV[2]}" 2 key1 key2 val1 val2
```

其中 script 是一段 Lua 脚本，numkeys 用于指定参数个数，key [key ...] 代表 redis 中的 key，arg [arg ...]为参数。



### 2. Redisson加锁流程

redisson 内部使用了大量的 lua 来保证原子操作。

```java
public void lock() {
    try {
        // 加锁
        lock(-1, null, false);
    } catch (InterruptedException e) {
        throw new IllegalStateException();
    }
}

private void lock(long leaseTime, TimeUnit unit, boolean interruptibly) throws InterruptedException {
    long threadId = Thread.currentThread().getId();
    // 尝试获取锁，null：代表获取到锁，没有获取到锁，返回key的剩余存活时间
    Long ttl = tryAcquire(-1, leaseTime, unit, threadId);
    // lock acquired
    if (ttl == null) {
        return;
    }

    RFuture<RedissonLockEntry> future = subscribe(threadId);
    if (interruptibly) {
        commandExecutor.syncSubscriptionInterrupted(future);
    } else {
        commandExecutor.syncSubscription(future);
    }

    try {
        while (true) {
            ttl = tryAcquire(-1, leaseTime, unit, threadId);
            // lock acquired
            if (ttl == null) {
                break;
            }

            // waiting for message
            if (ttl >= 0) {
                try {
                    future.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
                } catch (InterruptedException e) {
                    if (interruptibly) {
                        throw e;
                    }
                    future.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
                }
            } else {
                if (interruptibly) {
                    future.getNow().getLatch().acquire();
                } else {
                    future.getNow().getLatch().acquireUninterruptibly();
                }
            }
        }
    } finally {
        unsubscribe(future, threadId);
    }
    //        get(lockAsync(leaseTime, unit));
}
```







## 参考：

https://mp.weixin.qq.com/s/hoZB0wdwXfG3ECKlzjtPdw 