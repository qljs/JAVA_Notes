

## 一. Redis 为什么单线程速度还很快

Redis 的所有数据都放在内存中，所有操作都是基于内存，而且单线程避免了多线程切换的性能损耗。

Redis 采用 **epoll** 实现了 **IO 多路复用**，将连接信息和事件放在队列中，依次放入到文件事件分派器中，事件分派器将事件分发给事件处理器。 	

### Redis 的线程模型了解么

**Redis** 内部使用文件事件处理器 `file event handler`，这个文件事件处理器是单线程的，所以 **Redis** 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 **Socket**，根据 **Socket** 上的事件来选择对应的事件处理器进行处理。

文件事件处理器的结构包含 4 个部分：

- 多个 **Socket**
- IO 多路复用程序
- 文件事件分派器
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

多个 **Socket** 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 **Socket**，会将 **Socket** 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。



> #### pipeline

可以将多次IO往返的时间缩减为一次，前提是**pipeline**执行的指令之间没有因果相关性。使用**redis-benchmark**进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是**pipeline**批次指令的数目。



## 二. Redis的持久化

在 Redis 中有两种持久化方式，分别是：**RDB快照（snapshot）**和 **AOF（append-only file）**，在redis4.0开始，可以使用两种持久化的混合。



### 1. RDB

RDB持久化是将**某个时间点上的数据**保存到一个RDB文件中，该文件是一个二进制的压缩文件。

通过配置可以设置Redis生成快照的条件。

```sh
# save <seconds> <changes> seconds时间内至少一个key发生changes次改变进行持久化
```

在Redis中，提供了两个命令来手动持久化，分别是`SAVE`和`BGSAVE`，`SAVE`会阻塞Redis服务进程，直到持久化完成，而`BGSAVE`命令则是fork一个子进程来完成初始化，并不会阻塞父进程的读写操作，所以在Redis中采用的是第二种方式。

**bgsave的写时复制(COW)机制**

Redis 借助操作系统提供的写时复制技术（Copy-On-Write, COW），在生成快照的同时，依然可以正常处理写命令。简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。

**bgsave和save的对比：**

| 命令                  | save             | bgsave                                 |
| --------------------- | ---------------- | -------------------------------------- |
| I/O类型               | 同步             | 异步                                   |
| 是否阻塞redis其它命令 | 是               | 否（在生成子进程的时候会有短暂的阻塞） |
| 复杂度                | O(n)             | O(n)                                   |
| 优点                  | 不会消耗额外内存 | 不阻塞客户端命令                       |
| 缺点                  | 阻塞客户端命令   | 需要fork子进程，消耗内存               |



### 2. AOF

AOF持久化保存的是redis的写命令，在旧文件上进行追加，默认是不开启，在进行恢复时，会将这些命令重新执行，速度较慢。

通过配置可以开启触发 AOF 的条件：

```sh
appendonly no # 是否开启aof模式，默认不开启
appendfilename "appendonly.aof" # aof文件名字
#appendfsync always # 每次发生变化都写入aof文件，会影响redis性能
appendfsync everysec # 每秒钟写入一次，可能会丢失一秒内的数据
#appendfsync no # 由系统决定写入
```



**AOF文件重写**

AOF文件里可能有太多没用指令，所以AOF会定期根据**内存的最新数据**生成aof文件

例如，执行了如下几条命令：

```sh
127.0.0.1:6379> incr readcount
(integer) 1
127.0.0.1:6379> incr readcount
(integer) 2
127.0.0.1:6379> incr readcount
(integer) 3
```

重写之后，Redis会将这几条命令合并。

```sh
*3 
$3 
SET
$2
readcount
$1
3
```

这是一种resp协议格式数据，星号后面的数字代表命令有多少个参数，$号后面的数字代表这个参数有几个字符。

通过参数可以配置 AOF 的重写频率

```sh
# auto-aof-rewrite-min-size 64mb   //aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大
# auto-aof-rewrite-percentage 100  //aof文件自上一次重写后文件大小增长了100%则再次触发重写
```



当然AOF还可以手动重写，进入redis客户端执行命令**bgrewriteaof**重写AOF

注意，**AOF重写redis会fork出一个子进程去做(与bgsave命令类似)，不会对redis正常命令处理有太多影响**



### 3. 混合持久化

重启 Redis 时，我们很少使用 RDB来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 RDB来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。 Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。

通过如下配置可以开启混合持久化(**必须先开启aof**)：

```sh
# aof-use-rdb-preamble yes
```


如果开启了混合持久化，**AOF在重写时**，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写**这一刻之前**的内存做RDB快照处理，并且将RDB快照内容和**增量的 **AOF 修改内存数据的命令存在一起，都写入新的AOF文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。

于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，因此重启效率大幅得到提升。

混合持久化AOF文件结构如下：

![](../images/redis/aof.png) 





### 4. 不同持久化方式的对比

**RDB 的优缺点**

- RDB 会生成多个数据文件，每个文件代表某一时刻的所有数据，适合做冷备；
- RDB 对 Redis 对外提供的读写服务影响较小，因为 Redis 主进程只需要 fork 一个子进程，让子进程来进行持久化即可，但是数据文件特别大时，可能会导致短暂的停顿；
- 直接基于 RDB 的数据文件重启和恢复数据较快；
- 在 Redis 故障时，RDB 丢失的数据可能较多。



**AOF 的优缺点**

- 相对于 RDB，AOF丢失的数据通常更少，但通常比 RDB 更大，且写 QPS 会比RDB低；
- AOF 日志文件以`append-only`模式写入，没有寻址开销，写入性能非常高，文件不容易损坏；
- AOF 日志文件的命令通过可读较强的方式进行记录，这个特性非常**适合做灾难性的误删除的紧急恢复**。比如某人不小心用 `flushall` 命令清空了所有数据，只要这个时候后台 `rewrite` 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 `flushall` 命令给删了，然后再将该 `AOF` 文件放回去，就可以通过恢复机制，自动恢复所有数据。



## 三. Redis主从复制

当Redis单节点宕机后就无法对外提供服务，而且需要进行扩容时，单节点也很难满足需求，为了保证服务的高可用以及更大的存储，通常会将数据复制到多个服务器上。

Redis共提供了两种高可用的方案：**分区集群**和**哨兵模式**，在这两种模式中，主节点负责接收写操作，而从节点则负责提供读操作。



**主从复制的好处**

- 数据冗余，实现数据的热备份；
- 故障恢复，避免单点故障带来的服务不可用；
- 读写分离，负载均衡。主节点负载读写，从节点负责读，提高服务器并发量；
- 高可用基础，是哨兵机制和集群实现的基础。



### 1. 主从复制的配置

配置主从复制有两种方式：

1. 直接使用命令`SLAVEOF IP PORT`配置子节点的主机，这种方式只是临时配置，在服务重启后就会失效。
2. 修改配置文件`replicaof <masterip> <masterport>`，这种方式可以持久化，不会因为重启失效。



### 2. 主从复制的实现原理

**1、建立连接阶段**

该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备。

**步骤一：保存主节点信息**

**步骤二：建立socket连接**

当从节点发现有主节点可连接时，会与主节点创建socket连接，负责后续的复制工作，例如接收RDB文件，接收命令等。

**步骤三：发送ping命令**

从节点成为主节点的客户端后，会发送ping命令，检查socket是否可用，以及主节点是否能处理请求。

**步骤四：身份验证**

如果设置了密码，则需要进行身份验证。

**步骤五：发送从节点的端口信息**

身份验证之后，从节点会向主节点发送自己的IP+PORT，主节点会将信息保存在从节点对应的slave_listening_port字段中。



**2、数据同步阶段**

当主从节点建立连接后，便开始进行数据同步，从节点会向主节点发送psync命令，开始同步数据，数据同步共有两种方式：

- **全量复制**：当master收到psync命令后，fork出一个子进程生成最新的 RDB 文件，在持久化期间，master可以继续接收请求，并将修改数据的操作放入缓存中。当持久化完成后，将新的RDB文件发送给slave，slave将接收到的数据持久化并加载进内存，然后master再将缓存中的数据同步给子节点。
- **部分复制**：从2.8开始，Redis提供了部分复制功能。master在内存中缓存最近一段时间的数据，同时master和slave都维护了复制的数据下标offset和master的id，因此当slave和master断开重连后，会根据offset和master的id判断是否继续进行未完成的复制，当offset太旧或者master的id发生变化时，则会进行全量复制。



**主从复制（全量）流程**

![](..\images\zk\psync-all.png)



**主从复制（部分）流程**

![](..\images\zk\psync.png)







**3、命令传播阶段**

在数据同步完成后，主从节点进入命令传播阶段，在该阶段主节点会将自己执行的写命令发送给从节点，从节点接收并执行，从而保证与主节点数据一致。

而主节点除了发送写命令，还会维持心跳机制：PING和REPLCONF ACK。



## 四. 哨兵模式

Redis的主从复制，一旦主节点挂掉之后就无法进行写操作，需要手动重启主节点才能恢复，若发现只重启时间太长将严重影响系统的可用性，在Redis2.8版本之后引入了哨兵（Sentinel）。**哨兵模式的核心功能就是自动完成主从的切换。**

> **哨兵的功能：**

- 哨兵会不断检查主从节点是否正常工作；
- 当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点；
- 哨兵可以将故障转移的结果发送给客户端；
- 客户端连接哨兵获取当前主节点的地址，若地址发生变动，哨兵将通知客户端。



> **哨兵模式的配置**

在配置中只需要配置主节点的信息，哨兵会自动获取从节点的信息。

```shell
## sentinel.conf

# master-group-name:主节点的名称，
# ip：主节点IP port：主节点端口
# quorum：判断主节点主观下线的哨兵数量，需要注意的是，这个数量并不是决定主节点切换的数量，若要进行故障转移，需要选举出来一个哨兵作为领导者，并且获得超过半数哨兵的同意，才会进行故障转移
sentinel monitor <master-group-name> <ip> <port> <quorum>

# 判断一个节点失效的时间，如果在指定时间内，该节点没有回复ping命令或者返回错误值，则认为该节点失效
sentinel down-after-milliseconds <master-group-name> <milliseconds>

# 设置故障转移之后，一次同时复制新节点数据的节点数量
sentinel down-after-milliseconds <master-group-name> <number>

# 故障转移子阶段的失败时间，超出这个时间	
sentinel failover-timeout {masterName} {time}
```

- **主观下线（Subjectively Down，简称SDOWN）**：在心跳检测中没有在指定时间回复，单个哨兵会“主观”的判断节点已经下线；
- **客观下线（Objectively Down， 简称 ODOWN）**：指的是多个哨兵在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。



> **故障转移的步骤**

1. 发现主服务器已经进入客观下线状态，该哨兵先与其他哨兵通信，选举中哨兵的leader用于处理故障转移工作。
2. 哨兵每次选举都会对当前纪元（选举周期）进行自增， 每个纪元中只会选择一个哨兵leader，超过半数哨兵同意后当选。如果当选失败，那么在设定的故障迁移超时时间的两倍之后， 重新尝试选举。。
4. 哨兵选举成功后，从slave当中选出一个，并将它升级为主服务器。
5. 向被选中的从服务器发送 `SLAVEOF NO ONE` 命令，让它转变为主服务器。
6. 通过发布与订阅功能， 将更新后的配置传播给所有其他 Sentinel ， 其他 Sentinel 对它们自己的配置进行更新。
7. 向已下线主服务器的从服务器发送 [SLAVEOF](http://www.redis.cn/commands/slaveof.html) 命令， 让它们去复制新的主服务器。
8. 当所有从服务器都已经开始复制新的主服务器时， 领头 Sentinel 终止这次故障迁移操作。



**哨兵选择新的主节点原则**：

- 淘汰失效主节点下，被标记为主观下线、断线或最后一次回复PING命令时间大于五秒的从节点。
- 在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被淘汰。
- 在经历了以上两轮淘汰之后剩下来的从服务器中， 我们选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器； 如果复制偏移量不可用， 或者从服务器的复制偏移量相同， 那么带有最小运行 ID 的那个从服务器成为新的主服务器。



## 五. Redis集群

哨兵模式虽然实现了主从节点的自动切换，但是当master挂掉之后，进行主从切换时会出现短暂的**访问瞬断**，即在主从切换期间无法对外提供服务，而且哨兵模式只有一个主节点，没有办法支持很高的并发，内存大小也有限制，过大的内存会导致持久化文件过大，影响主从数据同步效率。自Redis3.0版本之后，开始提供了集群（Redis Cluster）。



### 1. 集群搭建

**集群的相关配置**

```sh
cluster-enabled yes # YES:当做集群节点启动。
cluster-config-file nodes-6379.conf # 存储集群节点信息的配置文件。
cluster-node-timeout 15000 # 最大断开时间，单位毫秒，节点在指定时间内无法访问，会判定为故障。
cluster-replica-validity-factor 10 # 从节点与主节点最大段断开时间与该因子乘积，则故障转移时不会考虑该节点。
cluster-migration-barrier 1 # 主节点的最少从节点数，大于这个数量，主节点失败，从节点才会迁移。
cluster-require-full-coverage yes # YES:所有可用节点为包含所有的哈希槽时，即包含了部分哈希槽的节点不可用，集群将停止写入。
luster-replica-no-failover no # YES 禁止在主节点在故障时进行故障转移，但可以手动转移
```



搭建集群的最低需要三个主节点。

1. 修改Cluster相关参数，开启集群模式；
2. 创建集群

该方法时基于Redis 5，

```shell
redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1

 src/redis-cli ‐‐cluster create ‐‐cluster‐replicas 1 172.16.33.52:6379 172.16.33.52:6380  172.16.33.217:6381 172.16.33.217:6382 172.16.32.18:6383 172.16.32.18:6384 
```

搭建集群：https://www.lagou.com/lgeduarticle/79982.html



### 2. 集群功能

在Redis集群中需要两个TCP端口：**一个用于与客户端的通讯，另一个用于集群总线，负责集群节点的通讯**，且两个端口的偏移是固定的1000。

**redis集群是一个由多个主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。Redis集群不需要 sentinel哨兵也能完成节点移除和故障转移的功能。**

![](..\images\zk\cluster.png)



> **Redis集群主要提供了两个功能：**

1. **数据分区**：在集群中，数据会在多个Redis节点间自动分片，每个节点都会存储**哈希槽**的一部分，Redis集群共有16384个哈希槽，例如有三个节点，A节点包含0~5000的哈希槽，B节点包含5001~1100的哈希槽，C节点包含1101~16384的哈希槽。

   当客户端连接到集群时，会将集群的槽位信息缓存一份到本地，这样客户端操作某个key时，可以通过槽位信息定位到对应的节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需 要纠正机制来实现槽位信息的校验调整。

   Redis集群没有实现一致性hash，而是采用了自己做的CRC16的简单hash算法。

2. **一定程度的可用性**：当一部分节点出现故障或无法与其余群集通信时，可以继续操作。



> **Redis集群的数据一致性**

Redis集群无法保证数据的强一致性，主要原因是它采用异步复制，即与从机同步时，主机不会等到从机确认后才回复客户端，因此当主机接收到一个写命令，若此时主机宕机，重新选为主机的从机可能未接收到主机发送的写命令，从而造成数据丢失。

但Redis集群也提供了`WAIT`命令来实现同步写入，降低了数据丢失飞风险，不过也不能保证数据强一致性。



### 3. 集群节点间的通信

任何文件系统中的数据分为数据和元数据。数据是指普通文件中的实际数据，而元数据指用来描述一个文件的特征的系统数据，诸如访问权限、文件拥有者以及文件数据块的分布信息(**inode...**)等等。在集群文件系统中，分布信息包括文件在磁盘上的位置以及磁盘在集群中的位置。用户需要操作一个文件必须首先得到它的元数据，才能定位到文件的位置并且得到文件的内容或相关属性。

维护集群的元数据有两种方式：集中式和gossip，redis集群采用的时gossip。

**集中式**

优点在于元数据的更新和读取时效性非常好，一旦元数据出现变更会立即更新到集中式的存储中，其他节点可以立即感知到，缺点在于元数据的更新压力全集中在一个地方，可能有存储压力。

**gossip**

gossip协议包含多种消息，包括ping，pong，meet，fail等等。 

- ping：每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元 数据；
- pong：返回ping和meet，包含自己的状态和其他信息，也可以用于信息广播和更新； 
- fail：某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。 
- meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信，不需要 发送形成网络的所需的所有CLUSTER MEET命令。发送CLUSTER MEET消息以便每个节点能够达到其他每个节点只需通 过一条已知的节点链就够了。由于在心跳包中会交换gossip信息，将会创建节点间缺失的链接。 

gossip协议的优点在于元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新， 有一定的延时，降低了压力；缺点在于元数据更新有延时可能导致集群的一些操作会有一些滞后。



### 4. 集群选举

当slave发现自己的master变为FAIL状态后，会尝试进行failover，期望成为新的master，多个slave竞争称为master的过程如下：

1. slave发现自己的mater状态变为FAIL，将自己记录的集群currentEpoch（选举周期）加1，并广播FAILOVER_AUTH_REQUEST信息；
2. 其他节点收到信息，判断消息合法性，主节点进行响应，发送FAILOVER_AUTH_ACK，每个选举周期只响应一次；
3. 尝试failover的节点收集master响应的FAILOVER_AUTH_ACK，当收到超过半数的master响应的ack后，当选新的master；
4. 发送广播消息通知其他节点。



## 附录

- https://segmentfault.com/q/1010000009106416
- https://www.javazhiyin.com/22943.html
- [Redis命令参考](http://redisdoc.com/list/llen.html)
- https://www.cnblogs.com/kismetv/p/9236731.html