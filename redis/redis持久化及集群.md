

## 一. Redis 为什么单线程速度还很快

Redis 的所有数据都放在内存中，所有操作都是基于内存，而且单线程避免了多线程切换的性能损耗。

Redis 采用 **epoll** 实现了 **IO 多路复用**，将连接信息和事件放在队列中，依次放入到文件事件分派器中，事件分派器将事件分发给事件处理器。



## 二. Redis的持久化

在 Redis 中有两种持久化方式，分别是：**RDB快照（snapshot）**和 **AOF（append-only file）**，在redis4.0开始，可以使用两种持久化的混合。



### 1. RDB

RDB持久化是将**某个时间点上的数据**保存到一个RDB文件中，该文件是一个二进制的压缩文件。

通过配置可以设置Redis生成快照的条件。

```sh
# save <seconds> <changes> seconds时间内至少一个key发生changes次改变进行持久化
```

在Redis中，提供了两个命令来手动持久化，分别是`SAVE`和`BGSAVE`，`SAVE`会阻塞Redis服务进程，直到持久化完成，而`BGSAVE`命令则是fork一个子进程来完成初始化，并不会阻塞父进程的读写操作，所以在Redis中采用的是第二种方式。

**bgsave的写时复制(COW)机制**

Redis 借助操作系统提供的写时复制技术（Copy-On-Write, COW），在生成快照的同时，依然可以正常处理写命令。简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。

**bgsave和save的对比：**

| 命令                  | save             | bgsave                                 |
| --------------------- | ---------------- | -------------------------------------- |
| I/O类型               | 同步             | 异步                                   |
| 是否阻塞redis其它命令 | 是               | 否（在生成子进程的时候会有短暂的阻塞） |
| 复杂度                | O(n)             | O(n)                                   |
| 优点                  | 不会消耗额外内存 | 不阻塞客户端命令                       |
| 缺点                  | 阻塞客户端命令   | 需要fork子进程，消耗内存               |



### 2. AOF

AOF持久化保存的是redis的写命令，在旧文件上进行追加，默认是不开启，在进行恢复时，会将这些命令重新执行，速度较慢。

通过配置可以开启触发 AOF 的条件：

```sh
appendonly no # 是否开启aof模式，默认不开启
appendfilename "appendonly.aof" # aof文件名字
#appendfsync always # 每次发生变化都写入aof文件，会影响redis性能
appendfsync everysec # 每秒钟写入一次，可能会丢失一秒内的数据
#appendfsync no # 由系统决定写入
```



**AOF文件重写**

AOF文件里可能有太多没用指令，所以AOF会定期根据**内存的最新数据**生成aof文件

例如，执行了如下几条命令：

```sh
127.0.0.1:6379> incr readcount
(integer) 1
127.0.0.1:6379> incr readcount
(integer) 2
127.0.0.1:6379> incr readcount
(integer) 3
```

重写之后，Redis会将这几条命令合并。

```sh
*3 
$3 
SET
$2
readcount
$1
3
```

这是一种resp协议格式数据，星号后面的数字代表命令有多少个参数，$号后面的数字代表这个参数有几个字符。

通过参数可以配置 AOF 的重写频率

```sh
# auto-aof-rewrite-min-size 64mb   //aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大
# auto-aof-rewrite-percentage 100  //aof文件自上一次重写后文件大小增长了100%则再次触发重写
```



当然AOF还可以手动重写，进入redis客户端执行命令**bgrewriteaof**重写AOF

注意，**AOF重写redis会fork出一个子进程去做(与bgsave命令类似)，不会对redis正常命令处理有太多影响**



### 3. 混合持久化

重启 Redis 时，我们很少使用 RDB来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 RDB来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。 Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。

通过如下配置可以开启混合持久化(**必须先开启aof**)：

           ```sh
# aof-use-rdb-preamble yes
           ```

如果开启了混合持久化，**AOF在重写时**，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写**这一刻之前**的内存做RDB快照处理，并且将RDB快照内容和**增量的**AOF修改内存数据的命令存在一起，都写入新的AOF文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。

于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，因此重启效率大幅得到提升。

混合持久化AOF文件结构如下：

![](../images/redis/aof.png) 

















## 10. Redis主从复制

当Redis单节点宕机后就无法对外提供服务，而且需要进行扩容时，单节点也很难满足需求，为了保证服务的高可用以及更大的存储，通常会将数据复制到多个服务器上。

Redis共提供了两种高可用的方案：**分区集群**和**哨兵模式**，在这两种模式中，主节点负责接收写操作，而从节点则负责提供读操作。



**主从复制的好处**

- 数据冗余，实现数据的热备份；
- 故障恢复，避免单点故障带来的服务不可用；
- 读写分离，负载均衡。主节点负载读写，从节点负责读，提高服务器并发量；
- 高可用基础，是哨兵机制和集群实现的基础。



**主从复制的配置**

配置主从复制有两种方式：

1. 直接使用命令`SLAVEOF IP PORT`配置子节点的主机，这种方式只是临时配置，在服务重启后就会失效。
2. 修改配置文件`replicaof <masterip> <masterport>`，这种方式可以持久化，不会因为重启失效。



**主从复制的实现**

**1、建立连接阶段**

该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备。

**步骤一：保存主节点信息**

**步骤二：建立socket连接**

当从节点发现有主节点可连接时，会与主节点创建socket连接，负责后续的复制工作，例如接收RDB文件，接收命令等。

**步骤三：发送ping命令**

从节点成为主节点的客户端后，会发送ping命令，检查socket是否可用，以及主节点是否能处理请求。

**步骤四：身份验证**

如果设置了密码，则需要进行身份验证。

**步骤五：发送从节点的端口信息**

身份验证之后，从节点会向主节点发送自己的IP+PORT，主节点会将信息保存在从节点对应的slave_listening_port字段中。



**2、数据同步阶段**

当主从节点建立连接后，便开始进行数据同步，从节点会向主节点发送psync命令，开始同步数据。

- 全量复制：主节点将RDB文件发送给从节点，复制全部的数据。
- 部分复制：复制部分数据到从节点。



**3、命令插播阶段**

在数据同步完成后，主从节点进入命令传播阶段，在该阶段主节点会将自己执行的写命令发送给从节点，从节点接收并执行，从而保证与主节点数据一致。

而主节点除了发送写命令，还会维持心跳机制：PING和REPLCONF ACK。



### 10.1 哨兵模式

Redis的主从复制，一旦主节点挂掉之后就无法进行写操作，需要手动重启主节点才能恢复，若发现只重启时间太长将严重影响系统的可用性，在Redis2.8版本之后引入了哨兵（Sentinel）。**哨兵模式的核心功能就是自动完成主从的切换。**

> **哨兵的功能：**

- **配置提供程序**：哨兵会不断检查主从节点是否正常工作；
- **配置提供程序**：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点；
- **配置提供程序**：哨兵可以将故障转移的结果发送给客户端；
- **配置提供程序**：客户端连接哨兵获取当前主节点的地址，若地址发生变动，哨兵将通知客户端。



> **哨兵模式的配置**

在配置中只需要配置主节点的信息，哨兵会自动获取从节点的信息。

```shell
## sentinel.conf

# master-group-name:主节点的名称，
# ip：主节点IP port：主节点端口
# quorum：判断主节点主观下线的哨兵数量，需要注意的是，这个数量并不是决定主节点切换的数量，若要进行故障转移，需要选举出来一个哨兵作为领导者，并且获得超过半数哨兵的同意，才会进行故障转移
sentinel monitor <master-group-name> <ip> <port> <quorum>

# 判断一个节点失效的时间，如果在指定时间内，该节点没有回复ping命令或者返回错误值，则认为该节点失效
sentinel down-after-milliseconds <master-group-name> <milliseconds>

# 设置故障转移之后，一次同时复制新节点数据的节点数量
sentinel down-after-milliseconds <master-group-name> <number>

# 故障转移子阶段的失败时间，超出这个时间	
sentinel failover-timeout {masterName} {time}
```

- **主观下线（Subjectively Down，简称SDOWN）**：在心跳检测中没有在指定时间回复，单个哨兵会“主观”的判断节点已经下线；
- **客观下线（Objectively Down， 简称 ODOWN）**：指的是多个哨兵在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。



> **故障转移的步骤**

1. 发现主服务器已经进入客观下线状态。
2. 对我们的当前纪元进行自增（详情请参考 Raft leader election ）， 并尝试在这个纪元中当选。
3. 如果当选失败， 那么在设定的故障迁移超时时间的两倍之后， 重新尝试当选。 如果当选成功， 那么执行以下步骤。
4. 选出一个从服务器，并将它升级为主服务器。
5. 向被选中的从服务器发送 `SLAVEOF NO ONE` 命令，让它转变为主服务器。
6. 通过发布与订阅功能， 将更新后的配置传播给所有其他 Sentinel ， 其他 Sentinel 对它们自己的配置进行更新。
7. 向已下线主服务器的从服务器发送 [SLAVEOF](http://www.redis.cn/commands/slaveof.html) 命令， 让它们去复制新的主服务器。
8. 当所有从服务器都已经开始复制新的主服务器时， 领头 Sentinel 终止这次故障迁移操作。



**哨兵选择新的主节点原则**：

- 淘汰失效主节点下，被标记为主观下线、断线或最后一次回复PING命令时间大于五秒的从节点。
- 在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被淘汰。
- 在经历了以上两轮淘汰之后剩下来的从服务器中， 我们选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器； 如果复制偏移量不可用， 或者从服务器的复制偏移量相同， 那么带有最小运行 ID 的那个从服务器成为新的主服务器。



### 10.2 Redis集群

自Redis3.0版本之后，开始提供了集群（Redis Cluster）。

在Redis集群中需要两个TCP端口：**一个用于与客户端的通讯，另一个用于集群总线，负责集群节点的通讯**，且两个端口的偏移是固定的1000.

> **Redis集群主要提供了两个功能：**

1. **数据分区**：在集群中，数据会在多个Redis节点间自动分片，每个节点都会存储**哈希槽**的一部分，Redis集群共有16384个哈希槽，例如有三个节点，A节点包含0~5000的哈希槽，B节点包含5001~1100的哈希槽，C节点包含1101~16384的哈希槽。

   Redis集群没有实现一致性hash，而是采用了自己做的CRC16的简单hash算法。

2. **一定程度的可用性**：当一部分节点出现故障或无法与其余群集通信时，可以继续操作。



> **Redis集群的数据一致性**

Redis集群无法保证数据的强一致性，主要原因是它采用异步复制，即与从机同步时，主机不会等到从机确认后才回复客户端，因此当主机接收到一个写命令，若此时主机宕机，重新选为主机的从机可能未接收到主机发送的写命令，从而造成数据丢失。

但Redis集群也提供了`WAIT`命令来实现同步写入，降低了数据丢失飞风险，不过也不能保证数据强一致性。



> Redis集群的参数配置

```shell
cluster-enabled yes # YES:当做集群节点启动。
cluster-config-file nodes-6379.conf # 存储集群节点信息的配置文件。
cluster-node-timeout 15000 # 最大断开时间，单位毫秒，节点在指定时间内无法访问，会判定为故障。
cluster-replica-validity-factor 10 # 从节点与主节点最大段断开时间与该因子乘积，则故障转移时不会考虑该节点。
cluster-migration-barrier 1 # 主节点的最少从节点数，大于这个数量，主节点失败，从节点才会迁移。
cluster-require-full-coverage yes # YES:所有可用节点为包含所有的哈希槽时，即包含了部分哈希槽的节点不可用，集群将停止写入。
luster-replica-no-failover no # YES 禁止在主节点在故障时进行故障转移，但可以手动转移
```



> 搭建集群

搭建集群的最低需要三个主节点。

1. 修改Cluster相关参数，开启集群模式；
2. 创建集群

该方法时基于Redis 5，

```shell
redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1
```





搭建集群：https://www.lagou.com/lgeduarticle/79982.html





## 11. Redis缓存穿透和缓存雪崩







## 附录

- https://segmentfault.com/q/1010000009106416
- https://www.javazhiyin.com/22943.html
- [Redis命令参考](http://redisdoc.com/list/llen.html)
- https://www.cnblogs.com/kismetv/p/9236731.html