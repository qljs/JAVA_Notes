 

## 1. 运行时数据区

运行时数据区在jdk1.8和之前版本有所不同。

![](..\images\jvm\runtime_area_1_6.png) 



JDK1.8运行时数据区：

![](..\images\jvm\runtime_area_1_8 .png)  



**线程共享**：

- 堆
- 方法区
- 直接内存（非运行时数据区）

**线程私有**：

- 虚拟机栈
- 程序计数器
- 本地方法栈



### 1.1 堆

**堆是线程共享的一块区域，大多数实例对象和数组都放在这个区域。但是一些对象如果发生逃逸，那么并不会放在堆上，而是在栈中分配内存。**

**堆是垃圾回收器管理的主要内存区域，因此也被称为GC堆，是容易出现OOM（Out Of Memory Error）的区域。堆可以被细分为新生代和老年代，新生代细分为：Eden空间，From Survivor，To Survivor。**



### 1.2 方法区/元空间

**方法区也是线程共享的区域，用于存储虚拟机加载的类元信息、常量、静态变量等数据，也被称为永久代。**

**从Jdk1.8起，方法区被彻底移除了，取而代之的元空间，元空间使用的直接内存。**



### 1.3 虚拟机栈

**虚拟机栈是线程私有的，是FILO的栈数据结构，生命周期和线程相同，由一个个栈帧组成，每个栈帧中都包括：局部变量表、操作数栈、动态链接、方法出口。**

- **局部变量表**：主要存放了编译期间可知的数据类型（基本数据类型）、对象引用；
- **操作数栈**：用于操作局部变量表中的信息，从中取值做一些操作，例如对int类型的赋值，加减乘除等；
- **动态链接**：存储程序运行期间见符号引用转化为的直接引用；
- **方法出口**：例如在方法A中调用方法B，在方法B执行结束后，需要知道接着从方法A哪里继续执行，方法出口存放着这类信息。

虚拟机栈中出现两种异常：`StackOverFlowError`和`OutOfMemoryError`。

- `StackOverFlowError`：若虚拟机大小不允许动态扩容时，当线程的请求栈深度超出虚拟机栈最大深度，就会抛出该异常；
- `OutOfMemoryError`：虚拟机栈没有空闲内存，且垃圾回收也无法提供足够内存，会抛出该异常。



### 1.4 程序计数器

程序计数器也是线程私有，记录着线程所执行的字节码行号，用来执行下一条指令。程序计数器时唯一不会出现OOM的区域。



### 1.5 本地方法栈

与虚拟机栈作用相似，是线程执行`native`方法时所用到的。



## 2. JVM内存参数设置

运行时数据区常用的一些参数：

- **堆内存参数**

    `-Xms`：堆初始内存

    `-xmx`：堆最大内存

   `-Xmn`：年轻代内存

-  **方法区**

  `-XX:MetaspaceSize`：元空间内存

  `-XX:MetaspaceSize`：元空间最大内存

- **栈**

  `-Xss`：栈内存




### 











