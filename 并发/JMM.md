[TOC]



# JMM&volatile关键字



## 1. 背景



> #### CPU缓存

​		由于内存的处理速度远远低于CPU的处理速度，所以CPU直接从内存中存取数据要等待一定的时间周期，为了提高系统效率，减少CPU的等待时间，在内存和CPU之间引入了**缓存**。

**CPU缓存**，即高速缓冲存储器，是位于CPU和内存间一种容量较小但是速度很高的存储器，共分为三级缓存：

- 一级Cache(L1 Cache)
- 二级Cache(L2 Cache)
- 三级Cache(L3 Cache)



> #### 缓存行(Cache line)

CPU中的高速缓存内部结构是一个拉链散列表，与HashMap的底层结构很相似，而高速缓存的最小存储单元就是**缓存行**。



> #### 缓存一致性协议

​		在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存 （MainMemory）。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是 也引入了新的问题：缓存一致性（CacheCoherence）。

​		当多个处理器的运算任务都涉及同一 块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步 回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都 遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、 MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol，等等。

​		常用的协议就是MESI，MESI是四种状态的首字母，代表了缓存行的四种状态：

|           状态           |                             说明                             |                           监听任务                           |
| :----------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|     M修改(Modified)      | 该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。 | 缓存行必须监听所有试图读取主存中该缓存行的操作，这种操作必须在该缓存行写回主存且置为共享状态前阻塞。 |
| E 独享、互斥 (Exclusive) | 该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。 | 缓存行必须监听其他缓存读取主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成共享状态。 |
|     S 共享 (Shared)      | 该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。 | 缓存行必须监听其他缓存行是该缓存行无效或者独享该缓存行的请求，并将干缓存变成无效状态 |
|     I 无效 (Invalid)     |                      该Cache line无效。                      |                              无                              |

在引入了缓存一致性协议后，CPU从主存读取数据如图：

![](..\images\bf\msei.png)



> ### MESI状态的转化

1. 当CPU1从主内存中读取变量（该变量触发了MESI协议，例如加了`volatie`关键字）时，若没有其他CPU读取过时，会将该缓存行置为E(独占)状态，同时通过嗅探机制监听是否有其他CPU操作该内存；
2. 在CPU1将变量写回主存前，CPU2读取该变量时，CPU1监听到有其他CPU操作该内存，此时会将该缓存行置为S(共享)状态；
3. 当CPU1修改完该变量后，在写回主存前，会将锁住该缓存行，并将该变量置为M(修改状态)，同时向主线中发送消息，将CPU2中的状态变为I(无效)状态；
4. CPU1将变量同步回主存，同时将该变量置为E(独占)状态。

当CPU1和CPU2中变量修改后，同时要更新回主存，此时会经过裁决，最终选定一个写回主存。





> #### 什么是线程

​		现代操作系统在运行一个程序时，会为其创建一个进程。而系统调度CPU的最小单位就是线程，也叫轻量级进程，在一个进程中可以有多个线程，每个线程都拥有自己的计数器、堆栈等信息。

​		线程的可以分为**用户级线程**和**内核级线程**。

- **用户线程(User-Level Thread)**：指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。另外，用户线程是由应用进程利用线程库创建和管理，不依赖于操作系统核心。不需要用户态/核心态切换， 速度快。操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。
- **内核线程(Kernel-Level Thread))**：线程的所有管理操作都是由操作系统内核完成的。内核保存线程的状态和上下文信息，当一个线程执行了引起阻塞的系统调用时，内核可以调度该进程的其他线程执行。

![](..\images\bf\ULT-KLT.png)





**在JVM中创建线程会通过库调度器，在内核空间中创建内核级线程。**



## 2. 什么是JMM

​		Java内存模型(Java Memory Model，简称JMM)是一种抽象的概念，并不真实存在，它描 述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构 成数组对象的元素）的访问方式。

​		JMM中规定所有的共享变量都存储在主内存中，所有线程都可以访问，但线程操作变量必须在工作内存中进行，先将变量从主内存中拷贝到自己的工作内存，然后对变量进行操作，完成操作后在将变量写回主内存。

​		基于JMM规范的线程、工作内存与主存的关系图：

![](..\images\bf\JMM.png)

> #### JMM中八种操作

- **lock(锁定)**：作用于主内存的变量，把一个变量标记为一条线程独占状态； 
- **unlock(解锁)**：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的 变量才可以被其他线程锁定；
- **read(读取)**：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中， 以便随后的load动作使用；
- **load(载入)**：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作 内存的变量副本中；
- **use(使用)**：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎；
- **assign(赋值)**：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存 的变量；
- **store(存储)**：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中， 以便随后的write的操作；
- **write(写入)**：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送 到主内存的变量中。





## 3. 并发编程的三个特性

1. **可见性**：当一个线程修改了共享变量，其他线程可以立即看到修改后的值。`volatile`关键字可以保证共享变量的可见性；
2. **原子性**：只一个操作不可被中断，要么全部执行，要么全不执行。`synchronized`关键字可以保证操作的原子性；
3. **有序性**：在保证执行结果与顺序执行结果相同的情况下，JVM会进行适当的指令重排，以最大限度发挥机器特性。`volatile`可以防止指令重排。



### 3.1 可见性

​		当一个共享变量被`volatile`关键字修饰时，它会保证修改的值立即被其他的线程看到，即修改的值立即更新到主存中，当其他线程需要读取时，它会去内存中读取新值。



### 3.2 有序性

> **指令重排**

只要最终结果与顺序执行结果相同，那个指令执行顺序可以和代码顺序不一样，该操作成为指令重排。

![](D:\JavaNotes\JavaNotes\images\bf\zlcp.png)



> **as-if-serial语义**

as-if-serial语义的意思是：不管怎么重排，都不能改变执行结果。



> happens-before原则

​		从JDK 5开始，Java使用新的JSR-133内存模型，提供了 happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数 据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下：

1. **程序顺序原则**：即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行；
2. **锁规则**： 同一个锁的解锁操作必然发生在后续的加锁之前；
3. **volatile规则** ：`volatile`修饰变量的写，先发生于读；
4.  **线程启动规则**：线程的start()方法先于它的每一个动作；
5. **传递性**： A先于B ，B先于C ，那么A必然先于C ；
6. **线程终止规则**： 线程的所有操作先于线程的终结； 
7. **线程中断规则**： 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断；
8. **对象终结规则**: 对象的构造函数执行，结束先于finalize()方法。



### 3.3 原子性

​	`volatile`关键字无法保证操作的原子性，通常会采用加锁的方式，例如`synchronized`。



## 4. volatile如何实现禁止指令重排

​	`volatile`关键字实现禁止指令重排是通过插入**内存屏障**来实现的。



> ### 内存屏障

内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个：**一是保证特定操作的执行顺序**，**二是保证某些变量的内存可见性**。

JMM中volatie的重排规则表：

| 是否能重排序 | 第二个操作 |             |             |
| ------------ | ---------- | ----------- | ----------- |
| 第一个操作   | 普通读/写  | volatile 读 | volatile 写 |
| 普通读/写    |            |             | NO          |
| volatile 读  | NO         | NO          | NO          |
| volatile 写  |            | NO          | NO          |



从表中可以看出：

- 当第二个操作是`volatile`写时，无论第一个操作是什么，都不允许指令重排；
- 当第一个操作时`volatile`读时，无论第二个操作是什么，都不允许指令重排；
- 当第一个操作是`volatile`写，第二个操作是`voaltile`读时，不允许指令重排。



> ### 屏障插入策略

​		为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。