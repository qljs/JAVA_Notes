[TOC]



## 1. 运行时数据区域

​		JAVA内存分为虚拟机栈、堆、方法区、程序计数器、本地方法栈。其中虚拟机栈、本地方法栈、程序计数器属于线程私有，而方法区和堆则是线程共享。

​		JDK1.8之后，取消了永久代，取而代之的元空间，元空间放在直接内存中(非运行时内存的一部分)						

 ![](D:\笔记\图片\1.png)



- **虚拟机栈**

​		虚拟机栈是线程私有的，随着线程的创建而创建，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象的引用）、操作数栈、方法出口等信息。

​		栈的大小可以固定也可以动态扩展，当栈大小固定，调用深度大于JVM允许的范围时，就会抛出StackOverFlowError错误，当动态扩展申请不到空间时，会抛出OutOfMemoryError.



- **本地方法栈**

  主要与虚拟机调用到Native方法有关。Native方法执行时，会在本地方法栈创建一个栈帧，用于存放该本地方

法的局部变量表，操作数栈等信息



- **程序计数器**

​		程序计数器是线程私有的内存空间，字节码解释器通过改变计数器的值来执行下一条字节码指令；在多线程的情况下，计数器会记录当前线程的执行位置，当线程切换时知道上次运行到的位置。

​		程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，其生命周期线程决定。



- **堆**

  堆在虚拟机启动的时候创建，主要用于存放对象实例，这部分空间可以通过GC进行回收。

​		堆可以细分为新生代、老年代；永久代在JDK1.8之后已经由元空间取代，永久代使用的是JVM的堆内存空间，而元空间使用的是物理空间。

 ![](D:\笔记\图片\20161012142326441.png)	

​		大部分情况，对象会先放在Eden代，在进行一次垃圾回收之后，若对象还存活，则会进入s1或s2，且年龄加1，当年龄增长到一定程度后(默认15)，会被放入老年代.



- **方法区**

​	主要用于存储虚拟机加载的类信息、常量池、方法信息等，jdk1.8之后替换为元空间，逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。



- **运行时常量池**

​		运行时常量池属于方法区的一部分，在Jdk1.7之后移到了堆内存中，Class文件中除了由类的版本，字段，方法，接口等信息外，还有常量池信息，用于存放编译期生成的各种字面量和符号引用。

​	

- **直接内存**

​        直接内存不是虚拟机运行是数据区域的一部分，也不是虚拟机规范中定义的内存区域，但是这块区域也被频繁的使用，也会出现OutOfMemoryError异常。

​		JDK1.4后新加入的NIO(NEW Input/Output)类，引入了一种基于通道(Channels)和缓存区(Buffers)的I/O方式，它可以直接使用Native函数库分配堆外内存，然后通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用来进行操作，避免了在Java堆和Native堆之间的数据复制。	



## 2. 对象的创建过程

![](D:\笔记\图片\create.png)



**1 类加载检查**

​		虚拟机遇到一条new指令时，首先检查这个指令的参数是否能在常量池定位到这个类的符号引用，并检查该符号引用代表的类是否已被加载、解析和初始化过，若没有，则必须先执行相应的类加载过程。



**2 分配内存**

​		在类加载检查通过后，虚拟机将会为新生对象分配内存，对象所需内存大小在类加载后便可以确定。分配的内存的方式由两种**”指针碰撞“**和**”空闲列表“**，**采用何种方式由Java堆是否规整决定，而Java堆是否规整又由采用的垃圾回收器的算法所决定**。

- **内存分配的两种方式**

![](D:\笔记\图片\Lesson Plan Mind Map.png)

- **内存分配并发问题**

在实际开发中，创建对象是很频繁的事情，虚拟机为了保护线程安全，通常采用以下两种方式：

​	 **CAS+失败重试**：CAS是乐观锁的一种实现方式，所谓乐观锁就是每次不加锁而是假设m没有冲突去完成某项操作，如果失败就重试，直到成功。虚拟机采用CAS+失败重试的方式保证更新操作的原子性。

​	 **TLAB**:为每个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB(线程本地分配缓存区)，当新对象大于TLAB剩余n内存或TLAB内存用尽时，再采用CAS方式分配。

**3初始化零值**

​	内存分配结束后，虚拟机需要将分配到的空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段对应的零值。

​	





## 3. 线程的生命周期

​	Java线程的生命周期分为六个状态

![](D:\笔记\图片\thread.png)



​	线程在创建后处于**新建状态**，当调用start()方法后，进入**就绪状态**，获取CPU时间片后进入**运行状态**

