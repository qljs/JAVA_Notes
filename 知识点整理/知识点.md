## 集合

### 1. HashMap

jdk1.7及之前版本，采用数组 + 链表的数据结构，线程扩容时采用头插法（作者认为后面的数据被查找的可能性更大），可能造成死循环。在1.8中，HashMap采用的时数组 + 链表 + 红黑树的结构，在扩容时，改用尾插法，避免了死循环的问题，但还是会造成数据覆盖。

链表转化为红黑树的条件：数组长度小于64时，先扩容（原长度的2倍），数组长度大于64且链表长度大于8时，转化为红黑树，链表长度小于6时，重新转为链表。

> ### 负载因子为什么要用0.75

负载因子选择0.75是对时间和空间的一种很好的权衡，比较大的值会减少空间开销，但是会增加查找的时间成本。

根据泊松分布，在负载因子默认为0.75的时候，单个hash槽内元素个数为8的概率小于百万分之一。

> ### 为什么容量要设置为2的n次方

为了数据的均匀分布，最直接的办法就是采用取模运算，而在HashMap中采用位运算`hash & (length - 1)`计算索引位置，是因为使用位运算的效率远高于取模运算。

位运算(&)效率要比代替取模运算(%)高很多，主要原因是位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。

如果容量是2的n次方，那么 `(length - 1)`所有位都变成了1，索引的位置取决于hashCode后几位的值，实现了均匀分布。

1.8中hash的计算方式`(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)`。

> ###  HashMap中主要参数

```java
// 数组的初始化大小，
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
// 数组最大容量
static final int MAXIMUM_CAPACITY = 1 << 30;
// 负载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;
// 链表转红黑树的默认节点数
static final int TREEIFY_THRESHOLD = 8;
// 红黑树退回链表的默认节点数
static final int UNTREEIFY_THRESHOLD = 6;
// 链表转红黑树时数组最小长度
static final int MIN_TREEIFY_CAPACITY = 64;
// 存放数据的数组
transient Node<K,V>[] table;
```

### 2. 线程安全的Map

> **Collections.synchronizedMap(new HashMap<>())**

```java
// 在synchronizedMap中维护了一个map和互斥锁mutex，其他方法通过synchronized(mutex)加锁保证线程安全
private final Map<K,V> m;     // Backing Map
final Object      mutex;        // Object on which to synchronize

SynchronizedMap(Map<K,V> m) {
    this.m = Objects.requireNonNull(m);
    mutex = this;
}

SynchronizedMap(Map<K,V> m, Object mutex) {
    this.m = m;
    this.mutex = mutex;
}
```



> #### Hashtable

Hashtable 保证线程安全是在方法上加锁`synchronized`来完成的。

> #### Hashtable 和 HashMap的区别

- **实现方式不同：**Hashtable 继承的是 Dictionary，而 HashMap 继承的是 AbstractMap。
- **初始化容量不同：**Hashtable 的初始化容量是11，而 HashMap 是16。
- **扩容机制不同：**Hashtable 的扩容规则是容量翻倍 +1，而 HashMap 是容量翻倍。
- **迭代器不同：**Hashtable 的迭代器`Dictionary`是安全失败机制（fail-safe），正是这种机制不允许键或值为 null，HashMap 的迭代器快速失败（fail-fast）。

> #### fail - safe 和 fail -fast

**快速失败（fail -fast）**，在迭代器遍历中，若修改集合，则会报错。在遍历过程中，每次遍历下一个元素前，会先比较 `modCount`（集合中元素数量）和开始遍历时记录的元素数量。

**安全失败（fail - safe）**：在遍历时不直接访问集合上的元素，而是先复制集合，然后遍历复制的集合，若值为 null 时，无法判断是不存在还是为 null。



> **ConcurrentHashMap**

- **在1.7中，把 table 分成了 n 个 Segment，Segment 继承了 ReentrantLock。**

put 方法的大致流程是：

1. 先定位到 Segment，
2. 然后再定位到 table 数组，
3. 不断尝试给头节点加锁，获取到锁后，再 put 元素。

- **在1.8中，重构了1.7，虽然还保留了 Segment（兼容1.7），但是没有用到，而是通过给数组中的头节点加 synchronized 锁。**

put 方法的大致流程为：

1. 先判断是否初始化，未初始化时保证只有一个线程完成初始化，`sizeCtl`值为 -1，表示其他线程在初始化，小于 -1时，表示几个线程在帮助扩容。
2. 数组头节点为空，CAS操作放入。
3. 如果正在扩容，线程会帮助转移数据，每个线程从后往前负责几个数组上的数据转移。
4. 头节点不为空，synchronized 锁住头节点，然后插入。
5. 统计 map 中元素数量，在并发下，不同线程统计自己的数据，最后进行相加。

在1.7和1.8中，都采用 volatile 关键字修饰了数组、值和下一个节点 。

```java
volatile V val;
volatile Node<K,V> next;
transient volatile Node<K,V>[] table;
```



### 3. List

> ArrayList

底层是数组实现的，查找效率高（内存连续），增删效率慢（取决于元素距离末尾的距离），默认初始长度为10，扩容为1.5倍。

在不指定index时，插入若需扩容，会通过`arraycopy()`方法将原数组复制到新的数组中，若指定index，需要扩容的情况下，会先通过`arraycopy()`进行扩容，之后会复制index之后的数组并后移，若不需要扩容，index之后的数组也会通过复制后移。

虽然 ArrayList 可以初始化长度，但是`set()`方法校验是和`size`比较大小。size是数组中元素的个数。



## I/O

### 1. BIO/NIO/AIO

> #### BIO

![](..\images\IO\BIO.png) 



> #### NIO

NIO（同步非阻塞）实现模式为一个线程可以处理多个请求（连接），客户端发送的请求都会注册到多路复用器上，然后多路复用器轮询处理请求。

![](..\images\IO\NIO.png)

**NIO相对于BIO非阻塞的体现就在，BIO的后端线程需要阻塞等待客户端写数据(比如read方法)，如果客户端不写数据线程就要阻塞， NIO把等待客户端操作的事情交给了selector，selector 负责轮询所有已注册的客户端，发现有事件发生了才转交给后端线程处 理，后端线程不需要做任何阻塞等待，直接处理客户端事件的数据即可，处理完马上结束，或返回线程池供其他客户端事件继续使用。还有就是 channel 的读写是非阻塞的。**

**NIO中核心组件**

- **Buffer（缓冲区）**：BIO 是面向流的，而 NIO 是面向缓冲区的，在 NIO 中数据的读写都是操作缓冲区。
- **Channel（通道）**：NIO 通过通道来读写，通道是双向的。
- **Selector（选择器）**：通过将通道注册到选择器上，来监听通道上发生的事件。









## Spring 

### 1. IOC

控制反转（IOC）是依赖倒置原则的一种思路，而 DI 是其中一种实现方式。

IOC是为了删除对象间的直接依赖关系，避免因底层类的改动，导致所有依赖它的类都要改变，就是我们常说的解耦。

在 Spring 中的体现就是将 bean 的创建、管理交给容量。

**依赖倒置原则**：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。

关于IOC更详细解释可以看看这两篇文章：



### 2. 循环依赖

```java
// 循环依赖的两个类，若都采用构造函数注入，就会报错，但是只有一个通过构造函数注入，并不一定会报错。
@Component
class A {
    @Autowired
    B b;
}

@Component
class B {
    @Autowired
    A a;
}
```

在Spring 中 通过三级缓存来解决循环依赖的问题：

- `singletonObjects`：缓存创建完成的 bean；
- `earlySingletonObjects`：存储早期的 bean；
- `singletonFactories`：bean 的早期引用，不是一个完整的 bean，只是一个 Instance。

在 A 完成实例化后，会先将 A 放入`singletonFactories`，之后开始填充属性，在这里发现依赖 B，然后开始创建 B，在 B 填充属性时，发现依赖 A，但是可以从三级缓存中去拿，之后 B 完成创建，继续去创建 A，其实为了解决循环依赖，两级缓存也可以实现，采用三级缓存主要时为了将**延迟对实例化阶段生成的对象的代理，只有真正发生循环依赖的时候，才去提前生成代理对象**。



### 3. 事务

```java
// 事务管理器，提供了事务管理功能
interface PlatformTransactionManager;

// 事务定义，定义了事务的隔离级别、传播行为等
// 隔离级别：读未提交、读已提交、可重复读、串行化
// 传播行为：
// PROPAGATION_REQUIRED（支持当前事务，没有则新建一个事务,有的话加入）
// PROPAGATION_SUPPORTS（如果当前有事务，加入当前事务；若没有，则以非事务的方式执行）
// PROPAGATION_MANDATORY（如果当前有事务，加入当前事务；若没有则抛出异常）
// PROPAGATION_REQUIRES_NEW（创建一个新的事务，若当前有事务，则将当前事务挂起）
// PROPAGATION_NOT_SUPPORTED（以非事务的方式执行，若当前有事务则将事务挂起）
// PROPAGATION_NEVER（以非事务方式运行，当前存在事务抛错）
// PROPAGATION_NESTED（若当前存在事务，则在嵌套事务中执行）
interface TransactionDefinition;

// 获取事务状态
interface TransactionStatus    
```



## Springboot

### 1. @SpringBootApplication 注解

主要包括三个核心注解：

- <font color="red">@SpringBootConfiguration</font>：定义配置类，包含了`@Configuration`注解；
- <font color="red">@EnableAutoConfiguration</font>：开启自动装配功能，springboot中很重要的一个注解，通过`@Import`注解导入了`AutoConfigurationImportSelector`，该类会去扫描`META-INF/spring.factories`中的组件，注入到容器中；
- <font color="red">@ComponentScan</font>：扫描包的注解，默认的路径是启动类下的包，这也是为什么启动类一般会放在最外层包。



## 并发

### 1.  缓存一致性协议

在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存 （MainMemory）。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是 也引入了新的问题：缓存一致性（CacheCoherence）。为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议。

> ### MESI（缓存一致性协议的一种）状态的转化

1. 当CPU1从主内存中读取变量（该变量触发了MESI协议，例如加了`volatie`关键字）时，若没有其他CPU读取过时，会将该缓存行置为E(独占)状态，同时通过嗅探机制监听是否有其他CPU操作该内存；
2. 在CPU1将变量写回主存前，CPU2读取该变量时，CPU1监听到有其他CPU操作该内存，此时会将该缓存行置为S(共享)状态；
3. 当CPU1修改完该变量后，在写回主存前，会将锁住该缓存行，并将该变量置为M(修改状态)，同时向主线中发送消息，将CPU2中的状态变为I(无效)状态；
4. CPU1将变量同步回主存，同时将该变量置为E(独占)状态。

当CPU1和CPU2中变量修改后，同时要更新回主存，此时会经过裁决，最终选定一个写回主存。



### 2. 用户线程、内核线程

- **用户线程(User-Level Thread)**：指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。另外，用户线程是由应用进程利用线程库创建和管理，不依赖于操作系统核心。不需要用户态/核心态切换， 速度快。操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。
- **内核线程(Kernel-Level Thread))**：线程的所有管理操作都是由操作系统内核完成的。内核保存线程的状态和上下文信息，当一个线程执行了引起阻塞的系统调用时，内核可以调度该进程的其他线程执行。

![](..\images\bf\ULT-KLT.png)



**线程生命周期：**

![](..\images\bf\thread.png)

### 3. JMM

Java内存模型(Java Memory Model，简称JMM)是一种抽象的概念，并不真实存在，它描 述的是一组规则或规范。

JMM中规定所有的共享变量都存储在主内存中，所有线程都可以访问，但线程操作变量必须在工作内存中进行，先将变量从主内存中拷贝到自己的工作内存，然后对变量进行操作，完成操作后在将变量写回主内存。

![](..\images\bf\JMM.png)



### 4. volatile

**volatile 可以保证有序性和可见性。**

> #### 可见性

对于被`volatile`修饰的变量，处理器在读取时会触发缓存一致性原则，操作的变量时共享变量时，再修改变量后，会想总线中发送消息，并将变量同步会主存，其他处理器通过嗅探发现变量被修改，会将自己缓存的变量置为无效状态，重新从内存中读取。

由于缓存一致性协议会导致不断的从主存嗅探和cas操作，若大量的使用 volatile 关键字会频繁的无效交互，到这总线带宽达到峰值，造成总线风暴。



> #### 有序性

**为了提高性能，再不影响指令执行结果的前提下，编译器和处理器会对指令进行重排优化。**

![](..\images\bf\zlcp.png)

- **编译器优化重排：**编译器在不改变单线程程序语义的前提下，重排语句的执行顺序。
- **指令集并行重排：**现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序;
- **内存系统重排：**由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。



> **as-if-serial语义**

**as-if-serial语义的意思是：不管怎么重排，都不能改变执行结果。**



> happens-before原则

​		从JDK 5开始，Java使用新的JSR-133内存模型，提供了 happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数 据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下：

1. **程序顺序原则**：即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行；
2. **锁规则**： 同一个锁的解锁操作必然发生在后续的加锁之前；
3. **volatile规则** ：`volatile`修饰变量的写，先发生于读；
4. **线程启动规则**：线程的start()方法先于它的每一个动作；
5. **传递性**： A先于B ，B先于C ，那么A必然先于C ；
6. **线程终止规则**： 线程的所有操作先于线程的终结； 
7. **线程中断规则**： 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断；
8. **对象终结规则**: 对象的构造函数执行，结束先于finalize()方法。



> #### 内存屏障

​	`volatile`关键字实现禁止指令重排是通过插入**内存屏障**来实现的。

内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个：**一是保证特定操作的执行顺序**，**二是保证某些变量的内存可见性**。

JMM中volatie的重排规则表：

![](..\images\bf\NCPZ.png) 



> #### volatile写操作插入内存屏障

![](..\images\bf\vol-write.png)



> #### volatile读操作插入内存屏障

![](..\images\bf\vol-read.png)



### 5. synchronized

​	`synchronized`内置锁是一种对象锁，是基于JVM内置锁来实现的，基于内部对象**Monitor**（监视器锁）的进入（monitorenter）和退出（monitorexit）实现同步功能，监视器锁依赖底层操作系统的Mutex lock（互斥锁），它是一个重量级的锁。

> #### 对象内存布局

在JVM中对象布局分为三块：

- **对象头**：比如 hash码，对象所属的年代，对象锁，锁状态标志，偏向 锁（线程）ID，偏向时间，数组长度（数组对象）等
- **实例数据**：对象中成员变量，方法等
- **对齐填充**：JVM中规定对象的大小必须是8字节的整数倍



> #### 锁升级

在JDK1.6之后，对JVM内置锁进行了重大优化，引入锁消除、锁粗化、轻量级锁、偏向锁、适应性自旋等等。锁的状态共有四种，分别为：**无锁状态**、**偏向锁**、**轻量级锁**和**重量级锁**。随着锁的竞争，锁会从偏向锁升级为轻量级锁，再升级为重量级锁，且**锁的升级时单向的**。

![](..\images\bf\syn.png)



### 6. AQS

AQS全程为AbstractQueuedSynchronizer，位于java.concurrent.util包，它定义了一套多线程访问共享资源的同步器框架，是一个依赖状态（state）的同步器，JUC中大多数同步器实现都是围绕等待队列、条件队列、独占、共享等行为，而AQS就是对这种行为的抽象。	



> #### 队列

AQS中定义了两种队列，分别是：

- **同步队列**：基于双向链表，FIFO的数据结构队列，Java中的CLH队列是原CLH队列的一个变种，线程有原来的自旋变为了阻塞。
- **条件队列**：是一个多线程间协调通信的工具类，使得某个或者某些线程一起等待某个条件（Condition），只有当该条件具备时 ，这些等待线程才会被唤醒，从而重新争夺锁。

![](D:\JavaNotes\JavaNotes\images\bf\queue.png)



> #### 公平锁和非公平锁

- **公平锁**：新线程会进入等待队列中，等待被唤醒，遵循FIFO。

  优点是所有线程都能获得资源，不会被饿死；缺点是吞吐量会下降，队列里除了第一个线程其他都会被阻塞，CPU唤醒线程消耗较大。

- **非公平锁**：新线程会先尝试获取锁，若失败进入等待队列，与公平锁相同，CPU需要唤醒的线程+1；若成功，则直接获取锁。

  优点是可以减少CPU唤醒线程消耗，提高吞吐量；缺点是队列中的线程可能会被饿死。

**AQS组件：

- `ReentrantLock`
- `Semaphore`：信号量，可以做单机限流
- `CountDownLatch`：允许 count 个线程阻塞在一个地方。
- `CyclicBarrier`：与 CountDownLatch 类似。



### 7. BlockingQueue

`BlockingQueue`阻塞队列，通常用链表或数组实现，主要有`FIFO`和`LIFO`两种，其实现是基于**AQS（CLH+条件队列+ReentrantLock）**。最经典的应用场景就是生产者-消费者。

```java
// ********* 入队 ***********
boolean add(E e); // 向队列尾插入元素，若队列已满，则抛错
boolean offer(E e); // 向队列尾插入元素，若队列已满，返回fasle
void put(E e) throws InterruptedException; // 向队列尾插入元素，若队列已满，则阻塞
//  ********* 出队 ***********
E take() throws InterruptedException; // 从队列头取出元素，若没有则阻塞
E poll(long timeout, TimeUnit unit) throws InterruptedException; // 从队列头取出元素，等待指定时间
int drainTo(Collection<? super E> c);  // 将队列中的全部元素放入指定集合中
```



### 8. 线程池

线程是稀缺资源，频繁的创建和销毁会大大降低系统的效率，为了降低获取线程的消耗，提高资源利用率，引入池化技术，而线程池正是其中之一。

使用线程池的好处：

- **降低资源消耗**：通过重复利用已创建的线程降低线程创建和销毁造成的消耗；
- **提高响应速度**：当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。



> #### ThreadPoolExecutor

**ThreadPoolExecutor的属性**

```java
int corePoolSize, // 线程池的核心线程数
int maximumPoolSize, // 线程池的最大线程数
long keepAliveTime, // 线程数大于核心线程时，空闲线程存活时间
TimeUnit unit, // 时间单位
BlockingQueue<Runnable> workQueue, // 等待执行任务的阻塞队列
ThreadFactory threadFactory,  // 线程工厂
// 拒绝策略
// 1、AbortPolicy：直接抛出异常，默认策略；
// 2、CallerRunsPolicy：用调用者所在的线程来执行任务；
// 3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；
// 4、DiscardPolicy：直接丢弃任务；
RejectedExecutionHandler handle
```



> #### 线程池的状态

线程池内部使用一个`AtomicInteger`类型的变量`ctl`维护两个值：运行状态(runState)和有效线程数量 (workerCount)。其中高3位保存runState，低29位保存workerCount。

|      状态      |                             说明                             |
| :------------: | :----------------------------------------------------------: |
|  **RUNNING**   | 线程池的初始状态就是RUNNING，在该状态时，线程池会接受新任务，处理阻塞队列中的任务 |
|  **SHUTDOWN**  |       不接受新提交任务，但是会继续处理阻塞队列中的任务       |
|    **STOP**    | 不接受新任务，也不处理阻塞队列中的任务，且会中断正在执行的任务 |
|  **TIDYING**   |           所有任务都已经执行完了，且有效线程数为0            |
| **TERMINATED** | 线程池处在TIDYING状态时，执行完terminated()之后，进入该状态需要有效线程为0，阻塞队列为空 |

![](..\images\bf\threadpool.png)



> ### ExecutorService执行任务的流程图

![](../images/bf/threadpool-execute.png)



## JVM

### 1. 运行时数据区

![](..\images\jvm\runtime_area_1_6.png) 



**JDK 1.8**

![](..\images\jvm\runtime_area_1_8 .png) 



### 2. 类的加载过程

类的加载过程包括以下步骤：**加载**—>**验证**—>**准备**—>**解析**—>**初始化**。

- **加载**：在磁盘上通过全限定类名查找定义此类的字节码文件，通过I/O读取字节流，将字节流所代表的静态存储结构转换为**方法区（元空间）**的**运行时数据结构**，并在内存中生成该类的类对象，作为**方法区（元空间）**数据的访问入口；

- **验证**：检验字节码文件的正确性，主要包括文件格式验证、元数据验证、字节码验证、符号引用验证；

- **准备**：给类的静态变量分配内存，并赋予默认值；该阶段进行内存分配仅包括静态变量，不包括实例变量，实例变量会在对象实例化时分配内存。

- **解析**：将常量池中的符号引用替换为直接引用，该阶段会把一些静态方法的符号引用替换为指向数据所在内存的**指针或句柄（直接引用**），这是**静态链接**的过程，**动态链接**则是在程序运行期间完成见符号引用替换为直接引用的。

- **初始化**：对类的静态变量赋值，执行静态代码块。



> #### 双亲委派机制

![](..\images\jvm\classloader.png)



### 3. JVM内存分配

- **对象优先在Eden区分配，空间不足时产生一次 Young GC（Minor GC），回收年轻代。**

- **大对象直接进入老年代**。
- **长期存活的对象将进入老年代。**
- **对象动态年龄判断，一批对象大于 Survivor 区一半时，大于这批对象最大年龄的进入老年代。**。
- **Minor GC后存活的对象Survivor区放不下。**

  

### 4. 如何判断一个对象可以被回收

- **引用计数法：**给对象添加一个引用，有引用时+1，引用失效-1，效率高，但是可能会有循环引用。
- **可达性分析：**以 GC Roots 的对象为起点向下搜索，标记非垃圾对象。可作为 GC Roots 的包括：静态变量引用的对象、常量引用的对象、虚拟机栈本地变量表中的引用的变量、本地方法栈中的变量引用的对象。

可达性分析中，不可达的对象也不一定时会回收，还需要经过两次标记：第一次标记筛选是否由必要执行 finalize 方法，第二次标记若在 finalize 方法中没有重新与引用链上的对象建立连接，则被回收。



### 5. 引用类型

- **强引用**：平时使用的就是强引用，对于强引用，垃圾回收器绝不会回收；
- **软引用**：被`SoftReference`软引用包裹的称为软引用，正常情况不会被回收，但是GC之后还是没有足够的空间存放新对象，则会把这些软引用的对象回收。软引用可以用来实现内存敏感的高速缓存。
- **弱引用**：被`WeakReference`弱引用包裹的称为弱引用，在GC时，不管是否有足够的空间，软引用都会被回收。
- **虚引用**：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。



### 6. 判断一个类是无用类

方法区回收的主要是无用类，判断一个类是否是无用类需要满足以下3个条件：

1. 该类的所有实例都被回收；
2. 加载该类的 ClassLoader 已经被回收；
3. 该类对应的 Class 对象没有在任何地方被引用，无法通过反射方法访问到该类。



### 7. 垃圾回收算法

> 在JVM中，垃圾回收分为两种分别是：**Minor GC**和**Major GC**。
>
> **Minor GC**：也叫**Young GC**，是指发生在年轻代的垃圾回收，Minor GC比较频繁，回收速度也较快；
>
> **Major GC**：也叫**Full GC**，一般回收老年代、年轻代、方法区的垃圾，频率较低，比Minor GC速度慢很多。



![](..\images\jvm\算法.png) 

- **标记清理算法：**标记出不需要回收的对象，之后回收未标记的对象。会产生空间碎片。
- **复制算法：**将内存复制成两块，每次使用其中一块，GC 后将存活的移到另一块。
- **标记整理算法：**标记不需要回收的对象，将存活对象移到另一端，然后清理掉另一端的对象，解决了空间碎片的问题，但是需要移动对象，效率较低。
- **分代收集算法：**分为年轻代（eden区、 from Survivor 、to Survivor）和老年代。



### 8. 垃圾回收器

- **Serial 收集器：**单线程垃圾回收器。
- **ParNew 收集器：**Serial 垃圾回收器的多线程版本。



## 数据库

### 1. 一条SQL的执行过程

在MySQL的8.0版本，移除了缓存。

![](..\images\mysql\sql.png)



### 2. 索引

**索引是帮助MySQL高效获取数据的排好序的数据结构。**

**而MySQL中使用的B+tree是对原B+tree的一种改进，MySQL在叶子节点之间加上了指针链接，这样对于跨节点的范围查询就无需返回父节点重复遍历，减少了I/O时间。**

![](..\images\mysql\b+tree2.png)



### 2. 聚集索引和非聚集索引

- **MyISAM引擎使用的索引是非聚集索引，即索引和数据是分离的，叶子节点存储的是数据的地址。**

![](..\images\mysql\MyIASM.png)

- **InnoDB引擎使用的索引是聚集索引，即索引和数据是在一起的，其数据存储在<font color="red">主键索引</font>的叶子节点。非主键索引的叶子节点存储的是主键索引。**

![](..\images\mysql\InnoDB.png)



### 3. 联合索引和最左匹配原则

**联合索引**即将多个索引建在一起，例如一张表有两个非主键索引，分别是id和name，将其合并为联合索引后(id,name)，在查找数据时或先比较索引[id]值的大小，若相同再去比较索引[name]的大小，这就是最左匹配原则。



### 4. MySQL中的锁

- **表锁：**表锁每次操作会锁住整张表。加锁快，开销小，不会出现死锁；但是锁的粒度加大，容易发生锁冲突，并发度低。
- **行锁：**每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁 冲突的概率最低，并发度最高。
- **间隙锁：**锁住一段范围的数据，例如删除一条不存在的记录时，会锁住数据库中比条件给定的值小的和大的这段区间内的数据。



### 5. 事务并发问题及隔离级别

> #### 事务并发问题

- **脏读：**事务读到了另一个事务未提交的事务。
- **不可重复读：**一个事务中多次读取数据，得到的结果不一样。
- **幻读：**一个事务多次读取的数据数量不一样。



> #### 隔离级别

为了解决并发事务代理的问题，数据库提供了事务隔离机制来解决这些问题，在MySQL中，默认的隔离级别是**可重复读**，查看数据库事务隔离级别`show variables like 'tx_isolation`，设置数据库隔离级别`set tx_isolation='REPEATABLE-READ'`。

|         事务隔离级别         |  脏读  | 不可重复读 |  幻读  |
| :--------------------------: | :----: | :--------: | :----: |
| 读未提交（READ-UNCOMMITTED） |  可能  |    可能    |  可能  |
|  读已提交（READ-COMMITTED）  | 不可能 |    可能    |  可能  |
| 可重复读（REPEATABLE-READ）  | 不可能 |   不可能   |  可能  |
|   可串行化（SERIALIZABLE）   | 不可能 |   不可能   | 不可能 |



### 6. MVCC机制

MVCC（多版本并发控制） 机制是 InnoDB 支持并发和回滚等事务功能的重要机制，保证了事务的一致性读，它只适用于**读已提交和可重复读两种隔离级别**。

**在MVCC中，有两种读操作：快照度和当前读。**

在InnoDB内部，为每一行添加了三个隐藏字段：

- **DB_TRX_ID**：该字段用于表示最后插入或更新改行的操作，在InnoDB中，删除被视为更新操作，行中的特殊位置会被标记为已删除。
- **DB_ROLL_PTR**：回滚指针，该字段指向undo log中记录。
- **DB_ROW_ID**：该字段包含一个行ID，随着插入新行而递增，可以理解为在我们自己没设置主键时候，MySQL自己维护的一个自增主键。



> #### Redo log、 bin log、 Undo log

- **bin log**：是mysql服务层产生的日志，记录引起数据库改变的操作，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的。对于事务，每次提交写入日志，非事务，每次执行成功写入。
- **redo log**： 记录了数据操作在物理层面的修改，mysql中使用了大量缓存，修改数据时不会直接修改磁盘中的数据，而是先修改缓存，当内存和磁盘数据不一致时，就会出现脏数据页，InnoDB会定期执行flush操作，同步数据。
- **undo log**：该日志保留了已更改行的旧版本信息，存在`rollback segment`，MVCC便是基于该日志来实现的，它分为 insert和 update，对于 insert undo log在事务提交后就可以删除。



> #### 一致性视图（快照）：ReadView

InnoDB 拥有一个自增的全局事务 ID，每当一个事务开启，在事务中都会记录当前事务的唯一 id，同时会将当前未提交的所有事务 ID 组成的数组传递给这个新事务。

**不同的隔离级别，生成的快照也不一样，在读已提交的级别下，每次SELECT都会生成新的快照，而在可重复读的级别下，第一次SELECT后生成快照，后续不在生成，沿用第一个。**

在ReadView有几个重要的属性，分别是：

- **low_limit_id**：高水位线，当前最大事务序号+1，大于等于low_limit_id且当前事务ID不等于low_limit_id，对当前事务都不可见；
- **up_limit_id**：低水位线，当前已开启未提交事务的最小值，小于up_limit_id的，对于当前事务都是可见的；
- **trx_ids**：记录ReadView生成时，所有已开启未提交事务的id集合；

![](..\images\mysql\read_view.png)



### 7. SQL优化

> #### Explain

![](..\images\mysql\explain.png)

- **id：**sql执行的序号，越大优先级越高。
- **select_type：**对应行是简单还是复杂的查询。
- **table：**操作的表。
- **type：**关联类型或访问类型，即MySQL如何查找表中的行。**性能从优到差：system > const > eq_ref > ref > range > index > all。**一般来说，要保证查询到range级，最好能到ref级。
- **possible_keys：**possible_keys列表示可能使用那些索引来查找，过该列是null且没有索引时，可以考虑添加索引来提高性能。
- **keys：**key列表示MySQL执行时真正走的索引，可以使用 force index来指定要采用的索引，也可以使用 ignore index来忽略索引。
- **key_len：**MySQL走的索引的字节数，通过这个可以计算出MySQL走的索引。
- **ref：**在key列记录的索引中，表查找值所用到的列或常量，常见的有const（常量），字段名。
- **rows：**该列表示大约要读取的行数，与结果的行数可能有差别。
- **Extra：**该列展示的额外信息。



> #### 导致索引无效的操作

- **最左前缀原则：**对于聚合索引，查询条件不是从最左开始，或者跳过中间索引。

- **不要再索引列上做任何操作，例如计算、函数、类型转换等，会导致索引失效**；

- ##### 使用不等于会导致索引失效；

- ##### is null 和not null 也会导致索引失效；

- ##### like操作以通配符开头会导致索引失效，对于 like key%，相当于时常量，而 like %key则是范围查找；

- ##### 尽量避免使用in或on，mysql也可能会放弃走索引；



> #### 优化方案

- **order by和group by优化：**尽量使用索引，聚合索引满足最左匹配原则。
- **分页查找优化：**对于分页查询`limit start num`，mysql会查询 start+num 条数据，然后抛弃前start条。可以计算出 start 值，减少查询范围。
- **join关联查询优化：**优化器一般会选择小表（不一定是数据量大小，而是看条件过滤后的数据量）作为驱动表，尽量满足 NLJ 算法，循环嵌套链接算法（NLJ），从驱动表循环读取数据，去另一张表中读取符合连接条件的行，基于块的循环嵌套链接算法（BNL），从驱动表中读取部分行放到缓冲区，然后逐行读取被驱动表，与缓冲据中的数据作比较。
-  **in 和 exsits优化：**小表驱动大表的原则，in 条件后用小表，exsits后用大表。

### 8. 主从

> #### 主从数据复制过程

![](..\images\mq\m-s.png) 

1. 主库执行更新操作，生成二进制日志文件 binLog；
2. 主库将日志文件 dump 给从库；

3. 从库将日志文件拷贝到中继日志 relay log；
4. 从库重做中继日志持久化到本地，日志重做只会执行一次。



> #### 主从复制的方式

- **同步复制：**当主库执行完一个事务后，所有的从库都执行了该事务才会返回给客户端。
- **异步复制：**主库在执行完事务后，会立即将结果返回，不用等待从库执行结束，MySQL默认的复制方式。
- **半同步复制：**主库在执行完事务后不是立即返回给客户端，而是等到至少一个从库接收并写入relay log中才返回。



### 9. 分库分表

**数据分片虽然解决了性能、可用性等问题，但是也带来的新的问题，例如跨表跨库查询、以及跨库事务等。**

> #### 分表

- **垂直拆分：**按字段进行拆分，常规的方案是冷热分离（使用高频率的字段放到一个表，低频字段放到一个表。）
- **水平拆分：**把一个表的数据，分配到不同的表，单表建议 500W。

> #### 分库

- **垂直分片**：又叫纵向拆分，根据不同的业务，将不同业务的表拆分到不同的数据库中，**核心理念是专库专用**。垂直分片往往需要对架构和设计进行调整**。通常来讲，是来不及应对互联网业务需求快速变化的；而且，它也并无法真正的解决单点瓶颈。**

- **水平分片：**又称为横向拆分，而是通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分。



## 缓存

### 1. redis基本数据类型

string、list、hash、set、zset。



### 2. redis线程模型

操作基于内存，文件事件处理器 `file event handler`，采用 **epoll** 实现了 **IO 多路复用**。

文件事件处理器的结构包含 4 个部分：

- 多个 **Socket**
- IO 多路复用程序
- 文件事件分派器
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

多个 **Socket** 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 **Socket**，会将 **Socket** 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。



### 3. redis 过期策略和内存淘汰机制

- **过期策略：**惰性+定期。
- **内存淘汰机制：**lru、random、ttl、no-enviction。



### 4. redis持久化

- **RDB：**存储某一时刻的数据，恢复较快，可能丢失较多数据，数据量比较多时，客户端可能会产生暂停，COW。
- **AOF：**append-only 方式追加，少了磁盘寻址，写入性能好，文件大，回复较慢，两个都开启时优先使用aof。

在4.0中redis加入了混合持久化，AOF在重写时会将这一刻之前的做RDB快照处理，并将RDB和增量AOF写入新的文件，在重写完成后，覆盖原来的AOF文件。



### 5. redis高可用

- **哨兵**：客观、主管下线，选举哨兵 leader 进行故障转移，完成之后通知其他从节点同步数据，更新哨兵中元数据。
- **集群**：槽位（数据分区）；收到其他过半主节点的ack当选。



### 6 redis数据同步

- **全量复制：**第一次连上主节点，或者重新选举主节点；fork 子进程RDB持久化，发送给从节点，之后同步缓存数据。 在同步rdb期间，若缓存满了，主节点则会关闭连接，造成同步失败，重新进行全量同步。
- **部分复制**：重连；根据主节点 id 和偏移量 offset 决定是否需要进行全量复制。



### 7. 缓存穿透、雪崩

-  **穿透**：访问不存在的key，大量请求落在数据库上；存储控制，针对恶意请求使用布隆过滤器（大的位数组，有时可能存在，没有时肯定没有）。
- **雪崩**：大量缓存失效，服务级联崩溃；过期时间随机，服务熔断降级。



### 8. 分布式锁

- **setnx**
- **锁并发和误删：**锁过期，其他线程拿到锁，执行结束后删除锁；lua脚本加时、redsion、redlock（GC或者时钟跳跃）。
- **集群下锁：**主从数据同步不及时，重新选举、集群脑裂。




### 9. 数据库和缓存一致

对于强一致性可以采用**内存队列**，将读写请求都放入内存队列中，性能较差。

对于可以偶尔不一致的情况，可以采用**消息队列订阅binLog异步更新**，或者延时双删，经典的Cache Aside Pattern（先更新数据，然后删除缓存，懒加载思想，用到是才重新生成缓存）等。



### 10. 热点key

- **热点key失效：**并发量大，重新构建复杂，通过互斥锁只允许一个线程重建，防止高并发下多个线程重复构建。
- **尽量保证缓存中都是热点key：**通过内存淘汰机制（LRU）。



### 11. Redis和Memcached的区别

redis支持更多的数据结构，并且支持原生集群，而Memcahced没有原生集群，依赖客户端实现集群分片。

在性能方面：redis只能使用单核，而Memcahced可以使用多核，在单核存储数据量较小时，redis的性能更好，而数据量较大时，memcached的性能较高。



## 分布式

### 1. zk节点类型和监听

**zk的节点类型：**

- 持久节点
- 持久顺序节点
- 临时节点
- 临时顺序节点

监听（watch）：通过实时监听节点与子节点的变化，并且实时收到通知。非常适用保障分布式情况下的数据一至性。zk上的监听是一次性的。



### 2. zk集群

**集群中的角色：**

| 角色     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| Leader   | 主节点，也叫领导者。提供读和写，通过选举产生                 |
| Follower | 为客户端提供读服务，如果是写服务则转发给 Leader。在选举过程中参与投票。 |
| Observer | 为客户端提供读服务器，如果是写服务则转发给 Leader。不参与选举过程中的投票，也不参与“过半写成功”策略。在不影响写性能的情况下提升集群的读性能。此角色于 ZooKeeper3.3 系列新增的角色。 |



> #### 选举

在**集群启动**或者**Leader挂掉**时，会触发Leader选举机制，在Leader选举中有几个比较重要的属性：

- myid：搭建集群时设置的服务器id；
- zxid：ZXID是一个长度64位的数字，其中低32位是按照数字递增，记录数据更次的次数。高32位是leader周期编号，每当选举出一个新的leader时，新的leader就从本地事物日志中取出ZXID,然后解析出高32位的周期编号，进行加1，再将低32位的全部设置为0。

**从3.4.10版本之后，默认的 Leader 选举算法是 FastLeaderElection。**

**zk启动时选举过程比较简单，即节点会先投自己一票，当发现有 myid 大于自己的节点时，会将票投给大于自己myid的节点，直到有超过半数投票的节点产生，选举结束，新加入的节点都会成为Follower。**

**当在运行中Leader宕机或失去连接后，同样会触发选举机制，但是和启动时有所不同：**

1. 每个节点状态更新为 LOOKING ，会发送投票信息（myid，zxid）；
2. 接受其他节点的的投票，判断有效性；
3. 先对比 zxid ，若相同再对比 myid；
4. 统计投票，有节点获取超过半数节点投票结束，该节点当选 Leader；
5. Follower 与 Leader 同步集群的所有副本，同步完成后，Leader进行消息广播，并对外提供事务服务。



> #### 消息同步机制

当客户端发送一个写请求时，若接收的请求的节点是 Leader，那么会接受请求，并同步给各个子节点，若接收请求的是 Follower，那个会将请求转发给 Leader 进行同步处理，(采用的是两阶段提交的方式)。

![](..\images\zk\mess_sync .png) 



> ### ZAB 协议介绍

ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。

**ZAB 协议两种基本的模式：崩溃恢复和消息广播**

- **崩溃恢复** ：当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的Leader服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，**所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致**。
- **消息广播** ：**当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。** 当一台同样遵守ZAB协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。





## 消息队列



### 1. 消息队列的共通问题

> #### 消息队列的主要使用场景

**异步、削峰、解耦**



> #### 消息队列模型

- **队列模型：**生成发送消息到队列中，队列中的消息可以被多个消费者消费，但是每条消息只能被一个消费者消费，RabbitMQ采用的该模型。
- **发布订阅模型：**将消息发送到一个主题（Topic）中，订阅该主题的消费者都可以消费这条消息，RocketMQ、Kafka采用的该模型。



> #### 消息可靠性

- 生产者端：发送消息后通过 Broker 的响应进行对应的处理，失败重试。例如 RabbitMQ 中的 confirm 机制，RocketMQ 的同步发送或异步发送回调。
- 消息中间件：开启消息的持久化，消息刷盘后再响应。
- 消费者端：业务逻辑执行完之后再 ack。



> #### 防止消息重复消费（保证幂等性）

- 记录关键的 key，消费消息前，先判断是否消费过。
- 利用数据库的唯一约束。



> #### 保证消息的有序性

- **全局有序：**一个生产者，一个队列，一个消费者单线程消费。
- **局部有序：**把消息根据一定策略发到固定的队列，然后由单个消费者单线程消费。



> #### 消息堆积

往往因为生产者生产速度和消费者消费速度不匹配造成的，可能是因为发送消息失败重试，也可能是消费本身消费速度慢。

1. 先定位消费慢的原因，优化消费逻辑，比如批量处理，多线程处理；
2. 如无法解决，可以进行扩容，增加消费者或者队列。





### 2. RabbitMQ

> #### AMQP协议

![](..\images\mq\amqp.png)

**AMQP模型几个核心概念：**

- **Message Queue**：消息队列；用作存储消息的缓冲区；
- **Exchanges**：交换器；生产者的消息会被投递到交换器上，然后又交换器根据路由 key 发送到对应的队列上。
- **Binding**：绑定；交换器和队列的虚拟绑定，可以通过路由 key 来绑定指定的队列；
- **Messages**：消息；生产者和消费者之间传递的数据信息，包括 properties(消息属性，例如优先级、存活时间等)和 body(消息体)；
- **Connection**：连接；程序和 broker 之间的连接，例如 TCP；
- **Channel**：通道；是连接内部的虚拟连接，用于向队列投递消息或者消费消息，是多路复用的；
- **Virtual Hosts**：虚拟机；一个逻辑上的概念，包含多个交换机和队列。



### 3. RocketMQ

相较于 RabbitMQ，RocketMQ的吞吐量、可用性、消息可靠性都更好，但是延时性较低。

RocketMQ 支持事务消息，采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息：

![](..\images\mq\rocketmq_tx.png)

## 十 微服务